// Script para monitorar cartas do Trello e notificar mudan√ßas de coluna
const fetch = require('node-fetch');
const fs = require('fs');

// Carregar vari√°veis de ambiente
require('dotenv').config();

// Configura√ß√µes do Trello
const TRELLO_API_KEY = process.env.TRELLO_API_KEY;
const TRELLO_API_TOKEN = process.env.TRELLO_API_TOKEN;
const BOARD_ID = process.env.BOARD_ID;

// Configura√ß√µes da API de notifica√ß√£o
const API_URL = process.env.API_URL || 'https://api-krolik.telezapy.tech';
const API_KEY = process.env.API_KEY;
const PHONE_NUMBER = process.env.PHONE_NUMBER;

// Configura√ß√µes do ambiente
const PORT = process.env.PORT || 3000;
const NODE_ENV = process.env.NODE_ENV || 'development';

// Validar vari√°veis de ambiente obrigat√≥rias
const requiredEnvVars = ['TRELLO_API_KEY', 'TRELLO_API_TOKEN', 'BOARD_ID', 'API_KEY', 'PHONE_NUMBER'];
const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);

if (missingVars.length > 0) {
  console.error('‚ùå Vari√°veis de ambiente obrigat√≥rias n√£o encontradas:', missingVars.join(', '));
  console.error('üìù Configure essas vari√°veis no Railway ou crie um arquivo .env');
  process.exit(1);
}

// Arquivo para armazenar o estado anterior das cartas
const STATE_FILE = 'trello-state.json';
const INIT_FLAG_FILE = 'trello-initialized.flag';

// Fun√ß√£o para verificar se √© a primeira execu√ß√£o
function isFirstRun() {
  return !fs.existsSync(INIT_FLAG_FILE);
}

// Fun√ß√£o para marcar que a inicializa√ß√£o foi feita
function markAsInitialized() {
  try {
    fs.writeFileSync(INIT_FLAG_FILE, new Date().toISOString());
    console.log('‚úÖ Sistema inicializado com sucesso');
  } catch (error) {
    console.error('Erro ao marcar inicializa√ß√£o:', error.message);
  }
}

// Fun√ß√£o para carregar o estado anterior
function loadPreviousState() {
  try {
    if (fs.existsSync(STATE_FILE)) {
      const data = fs.readFileSync(STATE_FILE, 'utf8');
      return JSON.parse(data);
    }
  } catch (error) {
    console.log('Erro ao carregar estado anterior:', error.message);
  }
  return {};
}

// Fun√ß√£o para salvar o estado atual
function saveCurrentState(cards) {
  try {
    const state = {};
    cards.forEach(card => {
      state[card.id] = {
        id: card.id,
        name: card.name,
        idList: card.idList,
        listName: card.listName || 'Unknown'
      };
    });
    fs.writeFileSync(STATE_FILE, JSON.stringify(state, null, 2));
    console.log('Estado salvo com sucesso');
  } catch (error) {
    console.error('Erro ao salvar estado:', error.message);
  }
}

// Fun√ß√£o para buscar todas as cartas do board
async function fetchAllCards() {
  try {
    const response = await fetch(`https://api.trello.com/1/boards/${BOARD_ID}/cards?key=${TRELLO_API_KEY}&token=${TRELLO_API_TOKEN}&list=true`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const cards = await response.json();
    console.log(`\n‚úÖ ${cards.length} cartas encontradas no board`);
    
    // Adicionar nome da lista para cada carta
    const cardsWithListNames = cards.map(card => ({
      ...card,
      listName: card.list ? card.list.name : 'Unknown'
    }));

    return cardsWithListNames;
  } catch (error) {
    console.error('‚ùå Erro ao buscar cartas:', error.message);
    return [];
  }
}

// Fun√ß√£o para buscar informa√ß√µes das listas
async function fetchLists() {
  try {
    const response = await fetch(`https://api.trello.com/1/boards/${BOARD_ID}/lists?key=${TRELLO_API_KEY}&token=${TRELLO_API_TOKEN}`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const lists = await response.json();
    return lists;
  } catch (error) {
    console.error('‚ùå Erro ao buscar listas:', error.message);
    return [];
  }
}

// Fun√ß√£o para enviar notifica√ß√£o
async function sendNotification(message) {
  try {
    const response = await fetch(`${API_URL}/api/send/${PHONE_NUMBER}`, {
      method: 'POST',
      headers: {
        'accept': 'application/json',
        'Authorization': `Bearer ${API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        body: message,
        connectionFrom: 5,
        ticketStrategy: "create"
      })
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const result = await response.json();
    console.log('‚úÖ Notifica√ß√£o enviada com sucesso:', result);
    return result;
  } catch (error) {
    console.error('‚ùå Erro ao enviar notifica√ß√£o:', error.message);
    return null;
  }
}

// Fun√ß√£o para detectar mudan√ßas de coluna
function detectColumnChanges(previousState, currentCards) {
  const changes = [];
  
  currentCards.forEach(card => {
    const previousCard = previousState[card.id];
    
    if (previousCard) {
      // Verificar se a carta mudou de lista
      if (previousCard.idList !== card.idList) {
        const change = {
          cardId: card.id,
          cardName: card.name,
          fromList: previousCard.listName,
          toList: card.listName,
          message: `üîÑ Carta "${card.name}" movida de "${previousCard.listName}" para "${card.listName}"`
        };
        changes.push(change);
        console.log(`\nüîÑ Mudan√ßa detectada: ${change.message}`);
      }
    } else {
      // Nova carta
      const change = {
        cardId: card.id,
        cardName: card.name,
        toList: card.listName,
        message: `üÜï Nova carta "${card.name}" criada na lista "${card.listName}"`
      };
      changes.push(change);
      console.log(`\nüÜï Nova carta detectada: ${change.message}`);
    }
  });

  // Verificar cartas removidas
  Object.keys(previousState).forEach(cardId => {
    const cardExists = currentCards.find(card => card.id === cardId);
    if (!cardExists) {
      const removedCard = previousState[cardId];
      const change = {
        cardId: cardId,
        cardName: removedCard.name,
        fromList: removedCard.listName,
        message: `üóëÔ∏è Carta "${removedCard.name}" foi removida da lista "${removedCard.listName}"`
      };
      changes.push(change);
      console.log(`\nüóëÔ∏è Carta removida detectada: ${change.message}`);
    }
  });

  return changes;
}

// Fun√ß√£o principal de monitoramento
async function monitorTrello() {
  const firstRun = isFirstRun();
  
  if (firstRun) {
    console.log('üéØ PRIMEIRA EXECU√á√ÉO - Coletando estado inicial...');
  } else {
    console.log('üöÄ Iniciando monitoramento do Trello...');
  }
  
  // Carregar estado anterior
  const previousState = loadPreviousState();
  console.log(`üìä Estado anterior carregado: ${Object.keys(previousState).length} cartas`);
  
  // Buscar estado atual
  const currentCards = await fetchAllCards();
  if (currentCards.length === 0) {
    console.log('‚ùå N√£o foi poss√≠vel buscar cartas. Tentando novamente em 30 segundos...');
    setTimeout(monitorTrello, 30000);
    return;
  }

  // Buscar informa√ß√µes das listas para nomes mais leg√≠veis
  const lists = await fetchLists();
  const listNames = {};
  lists.forEach(list => {
    listNames[list.id] = list.name;
  });

  // Atualizar nomes das listas nas cartas
  currentCards.forEach(card => {
    card.listName = listNames[card.idList] || 'Unknown';
  });

  if (firstRun) {
    // PRIMEIRA EXECU√á√ÉO: Apenas salvar estado inicial
    console.log('üìù Salvando estado inicial das cartas...');
    saveCurrentState(currentCards);
    markAsInitialized();
    
    console.log(`‚úÖ Estado inicial salvo com ${currentCards.length} cartas`);
    console.log('üîî A partir da pr√≥xima verifica√ß√£o, notifica√ß√µes ser√£o enviadas para mudan√ßas');
    
    // Mostrar resumo das cartas coletadas
    console.log('\nüìã Cartas coletadas no estado inicial:');
    const listSummary = {};
    currentCards.forEach(card => {
      if (!listSummary[card.listName]) {
        listSummary[card.listName] = 0;
      }
      listSummary[card.listName]++;
    });
    
    Object.entries(listSummary).forEach(([listName, count]) => {
      console.log(`  üìå ${listName}: ${count} cartas`);
    });
    
  } else {
    // EXECU√á√ïES SEGUINTES: Detectar mudan√ßas e notificar
    const changes = detectColumnChanges(previousState, currentCards);
    
    // Enviar notifica√ß√µes para cada mudan√ßa
    if (changes.length > 0) {
      console.log(`\nüì± Enviando ${changes.length} notifica√ß√£o(√µes)...`);
      
      for (const change of changes) {
        await sendNotification(change.message);
        // Aguardar 2 segundos entre notifica√ß√µes para evitar spam
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
      
      console.log('‚úÖ Todas as notifica√ß√µes foram enviadas!');
    } else {
      console.log('‚úÖ Nenhuma mudan√ßa detectada');
    }

    // Salvar estado atual
    saveCurrentState(currentCards);
    
    // Mostrar resumo das cartas atuais (apenas se houver mudan√ßas ou a cada 10 verifica√ß√µes)
    if (changes.length > 0) {
      console.log('\nüìã Resumo ap√≥s mudan√ßas:');
      const listSummary = {};
      currentCards.forEach(card => {
        if (!listSummary[card.listName]) {
          listSummary[card.listName] = 0;
        }
        listSummary[card.listName]++;
      });
      
      Object.entries(listSummary).forEach(([listName, count]) => {
        console.log(`  üìå ${listName}: ${count} cartas`);
      });
    }
  }

  // Agendar pr√≥xima verifica√ß√£o (a cada 30 segundos)
  console.log('\n‚è∞ Pr√≥xima verifica√ß√£o em 30 segundos...');
  setTimeout(monitorTrello, 30000);
}

// Servidor HTTP simples para Railway (health check)
const http = require('http');

const server = http.createServer((req, res) => {
  if (req.url === '/health') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ status: 'ok', service: 'trello-monitor' }));
  } else {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('Trello Monitor est√° rodando!');
  }
});

// Fun√ß√£o para iniciar o monitoramento
function startMonitoring() {
  const firstRun = isFirstRun();
  
  console.log('üéØ Monitor de Trello iniciado!');
  
  if (firstRun) {
    console.log('üÜï PRIMEIRA EXECU√á√ÉO DETECTADA');
    console.log('üìù Coletando estado inicial das cartas (sem notifica√ß√µes)');
    console.log('üîî Notifica√ß√µes come√ßar√£o a partir da segunda verifica√ß√£o');
  } else {
    console.log(`üì± Notifica√ß√µes ser√£o enviadas para: ${PHONE_NUMBER}`);
    console.log('üîî Sistema j√° inicializado - monitorando mudan√ßas');
  }
  
  console.log(`üîç Verificando mudan√ßas a cada 30 segundos...`);
  console.log(`üåê Servidor HTTP rodando na porta ${PORT}`);
  console.log('Pressione Ctrl+C para parar o monitoramento\n');
  
  // Iniciar servidor HTTP
  server.listen(PORT, () => {
    console.log(`‚úÖ Servidor HTTP iniciado na porta ${PORT}`);
  });
  
  monitorTrello();
}

// Tratamento de sa√≠da graciosa
process.on('SIGINT', () => {
  console.log('\n\nüõë Monitoramento interrompido pelo usu√°rio');
  server.close(() => {
    console.log('üõë Servidor HTTP fechado');
    process.exit(0);
  });
});

process.on('SIGTERM', () => {
  console.log('\n\nüõë Recebido SIGTERM, encerrando graciosamente...');
  server.close(() => {
    console.log('üõë Servidor HTTP fechado');
    process.exit(0);
  });
});

// Iniciar monitoramento
startMonitoring();


